<?php/** * Asset Component Manager * This was inspired by Sage's asset api.  *  * @version 1.0 */namespace Monk\Assets;class AssetComponent {        const version = '1.0';    // Default manifest model    private $manifest = [        'name' => '',        'version' => '',        'main' => '',        'dependencies' => [],        'devDependencies' => [],        'overrides' => [],    ];        // The directory relative to the requested component's dir where dependencies may be found. Defaults to bower_components    private $bower_dir  = 'assets';        // List of files to build from manifest from. Loops from list of files which, if exists, is loaded into the manifest in the order they are defined.    // Note that all found files will be loaded with the latter files overriding the properties of the former.    // This can be handy for modifying or appending a default bower structure with properties that otherwise would be incompatible with other applications.    private $devManifests   = [ '.bower.json', 'bower.json' ];    private $manifests      = [ '.bower.json', 'bower.json', 'assets.json' ];        // @todo Implement. Assets could nominate to be loaded from external networks with a fallback generated if they fail to load.    private $cdn = [        'google'    => 'https://ajax.googleapis.com/ajax/libs/%handle%/%version%/%resource%',        'maxcnd'    => 'https://oss.maxcdn.com/%handle%/%version%/%resource%',        'cdnjs'     => '//cdnjs.cloudflare.com/ajax/libs/%handle%/%version%/%resource%s'    ];        // Component dependencies as defined by the generated manifest file. Note this also incudes devDependencies when in development mode.    private $dependencies = [        'script'    => [],        'style'     => []    ];        // @todo Document    private $registered = [        'script'    => [],        'style'     => []    ];    /**     * Generates a manifest for the requested component and registers its assets and dependencies with wp.     *     * @param string $path      The path to the component to load, RELATIVE to the active theme's stylesheet directory!     * @param string $bower_dir The directory that stores bower components, relative to the component's path.     * @param array  $overrides An array of properties to override the manifest file with. This works in the same spirit as the 'overrides' property in a      *               bower file and in fact is used internally to pass on override values that were defined by the dependant component.     */    function __construct($path = '', $bower_dir = null, $overrides = []) {        // Construct absolute directory based on $path and uri reference        $dir = apply_filters('monk\component_dir', get_stylesheet_directory() . $path, $path);        $uri = apply_filters('monk\component_uri', get_stylesheet_directory_uri() . $path, $path);        //         $style_deps = [];        $script_deps = [];                // If component exists then get to work.        if (is_dir($dir)) {            // Determin bower components' directory.            if (is_string($bower_dir)) { // If the $bower_dir is passed then assigns it as the directory.                $this->bower_dir = $bower_dir;            } elseif (is_readable($fpath = $dir . '/.bowerrc')) { // Else if check if a .bowerrc file exists and, if so, parses it and checks if it contains a 'directory' property.                $bowerrc = (array) json_decode(file_get_contents($fpath, true));                if (isset($bowerrc['directory']) and ! empty($bowerrc['directory']))                    $this->bower_dir = $bowerrc['directory'];            } // if all the above conditions are not met, then the bower directory befaults to 'bower_components'.                        // Default component name            $name = basename($path);                        // Populate critical manifest properties with default values and then filter manifest model before generating data.            $this->manifest = apply_filters('monk\component_manifest', ['name' => $name, 'main' => is_readable("$dir/$name.js") ? "./$name.js" : ''] + $this->manifest);            // Determine the asset manifests to use depending on the WP environment            $files = IS_DEV ? $this->devManifests : $this->manifests;            // Loop through files and attempts to generate a manifest by loading each of the files it founds into the manifest model.            foreach ((array) apply_filters('monk\manifest_files', $files) as $file)                if (is_readable($fpath = "$dir/$file"))                    $this->manifest = array_merge($this->manifest, (array) json_decode(file_get_contents($fpath), true));                          // Finally merge manifest array with the $overrides array parameter.            $this->manifest = array_merge($this->manifest, (array)$overrides);                        /*             * Once a manifest is generated, a manifest will then be created for each dependency (this includes devDepedencies when in development mode).             * The manifest will be assigned to its dependency property in the manifest's dependencies/devDependencies array.             */            foreach ([0 => 'dependencies'] + (IS_DEV ? [1 => 'devDependencies'] : []) as $key) {                foreach ($this->manifest[$key] as $dep => $v) {                    $cpath = false;                     // Components path                    // Check for dependency component path, relative to the current component's directory.                    // By default, it first attempts to find the component as a sub directory within the component's path, then it will attempt                    // to check adjacent directorys for the dependency.                    /**                     * @todo Improve the way it searches for component dependencies                     */                    foreach (apply_filters('monk\assets\dependency_path', [                        "/$this->bower_dir/$dep",                        "/../../$this->bower_dir/$dep"                    ], $dep, $key, $this->manifest) as $p) {                        if (is_dir($dir . $p)) {                            $cpath = $p;                            break;                        }                    }                    if ($cpath) {                        $overrides = isset($this->manifest['overrides'][$dep]) ? $this->manifest['overrides'][$dep] : [];                        $component = new AssetComponent($path . $cpath, $this->bower_dir, $overrides);                        $this->manifest[$key][$dep] = $component->get_component();                                            } else                        $this->manifest[$key][$dep] = false;                    /*                     * Check if the dependency is registered. If so, then earmark it as a depencency when registering the current component through wp.                     * This check is done through wp, regardless whether the dependency's directory was found or not since it may be asking                     * for a dependency that was registered elsewhere within the application. Like JQuery UI for example.                     *                      * @todo Storing same dep manifest twice is not optimal!                     */                    if (wp_script_is($dep, 'registered'))                        $this->dependencies['script'][$dep] = $v;                    if (wp_style_is($dep, 'registered'))                        $this->dependencies['style'][$dep] = $v;                }            }            $this->dependencies = apply_filters('monk/assets/component/dependencies', $this->dependencies, $this->manifest);            // Script/Style register arguments to use            $name = $this->manifest['name'];            $style_deps = array_keys((array) $this->dependencies['style']);            $script_deps = array_keys((array) $this->dependencies['script']);            $version = apply_filters('monk/assets/component/version', $this->manifest['version'], $this->manifest);            /*             * In modern web development, scripts loaded in the head is very much the exception rather than the rule. Thus all scripts are             * by default set to print in the footer. This can be overriden by a filter. Note that modifying this for a component will affect             * all assets registered as a dependency of that component. For example, setting bootstrap-sass to print in the head could make all             * it's individual scripts print in the head as well, however this can also be controlled on the asset level as well.             */            $in_footer = apply_filters('monk/assets/component/js_to_footer', true, $name, $this->manifest);            foreach ((array) $this->manifest['main'] as $asset) {                if (!empty($asset)) {                    $info = pathinfo($asset);                    $slug = $name === $info['filename'] ? 'core' : trim(str_replace('.', '-', $info['filename']));                    $handle = "{$name}-$slug";                    $src = "$uri/" . ltrim($asset, '\\/');                    /* TODO: Account for assets that indicate an entire directory */                    if (isset($info['extension'])) {                        switch ($info['extension']) {                            case 'css' :                                // Check if stylesheet shares directory with a scss file of the same name. If so then it's assumed it will be imported into the main style.                                if(!file_exists(substr($asset, 0, -4) . ".scss")) {                                    wp_deregister_style($handle);                                    wp_register_style($handle, $src, [], $version);                                    array_push($style_deps, $handle);                                    $this->registered['style'][] = $handle;                                }                                break;                            case 'js' :                                wp_deregister_script($handle);                                wp_register_script($handle, $src, [], $version, apply_filters('monk/assets/component/js_to_footer', $in_footer, $handle, $this->manifest));                                array_push($script_deps, $handle);                                $this->registered['script'][] = $handle;                                break;                        }                    }                }            }            if (!empty($this->registered['style'])) {                wp_deregister_style($name);                wp_register_style($name, false, $style_deps, $version, 'all');            }            if (!empty($this->registered['script'])) {                wp_deregister_script($name);                wp_register_script($name, false, $script_deps, $version, $in_footer);            }            /*             * Add these filters to patch a short-coming with WP's script printing that prevents dependency assets registered for the footer             * from being printed.             */            add_filter('script_loader_src', [$this, 'remove_component_asset'], 10, 2);            add_filter('print_scripts_array', [$this, 'enqueue_component_assets'], 99);        }    }    function remove_component_asset($src, $handle) {        if (($key = array_search($handle, $this->registered['script'])) !== false)            unset($this->registered['script'][$key]);        return $src;    }    function enqueue_component_assets($to_print) {        if (($key = array_search($this->manifest['name'], $to_print)) !== false and empty($this->registered['script']))            unset($to_print[$key]);        else {            $assets = array_diff($this->registered['script'], $to_print);            if (!empty($assets)) {                $to_print = array_slice($to_print, 0);                ($key = array_search($this->manifest['name'], $to_print)) !== false && array_splice($to_print, $key, 1, $assets);            }        }        return $to_print;            }    /**     * Returns a component's manifest     *      * @return array The component's manifest     */    function get_component() {        return $this->manifest;            }}